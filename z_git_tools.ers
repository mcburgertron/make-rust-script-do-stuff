#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! anyhow = "1"
//! atty = "0.2"
//! clap = { version = "4", features = ["derive"] }
//! dialoguer = "0.11"
//! dirs = "5"
//! serde = { version = "1", features = ["derive"] }
//! tempfile = "3"
//! toml = "0.8"
//! ```

use anyhow::{anyhow, bail, Context, Result};
use atty::Stream;
use clap::{Parser, Subcommand};
use dialoguer::Input;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Write as IoWrite;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use std::process::{Command, Output};
use std::sync::{Arc, Mutex};
use std::thread;
use tempfile::NamedTempFile;

const CONFIG_DIR_NAME: &str = ".make-rust-script-do-stuff";
const CONFIG_FILE_NAME: &str = "z-git-tools.toml";

#[derive(Parser, Debug)]
#[command(name = "z-git-tools", about = "Manage multiple git repositories in the current directory")]
struct Cli {
    /// Print commands without executing them
    #[arg(long)]
    dry_run: bool,

    /// Skip GitHub token usage
    #[arg(long)]
    no_gh: bool,

    /// Directory whose child repos should be processed (defaults to current directory)
    #[arg(long, value_name = "PATH")]
    root: Option<PathBuf>,

    /// Override config file path
    #[arg(long)]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: CommandKind,
}

#[derive(Subcommand, Debug, Clone, Copy)]
enum CommandKind {
    #[command(name = "status")]
    Status,
    #[command(name = "pull")]
    Pull,
    #[command(name = "fetch-status")]
    FetchStatus {
        #[arg(long)]
        include_current: bool,
        #[arg(long)]
        no_prune: bool,
    },
}

#[derive(Debug, Serialize, Deserialize, Default)]
struct Config {
    #[serde(default)]
    known_accounts: Vec<String>,
    #[serde(default)]
    repos: HashMap<String, RepoConfig>,
}

#[derive(Debug, Serialize, Deserialize, Default, Clone)]
struct RepoConfig {
    account: Option<String>,
    #[serde(default)]
    skip: bool,
}

#[derive(Clone)]
struct RepoEntry {
    name: String,
    path: PathBuf,
}

#[derive(Clone)]
struct RepoTask {
    entry: RepoEntry,
    account: Option<String>,
}

#[derive(Debug)]
struct JobResultOutput {
    output: String,
}

struct AppContext {
    dry_run: bool,
    no_gh: bool,
    interactive: bool,
    config_path: PathBuf,
    config: Config,
    config_dirty: bool,
}

impl AppContext {
    fn new(dry_run: bool, no_gh: bool, config_path: PathBuf, config: Config) -> Self {
        let interactive = atty::is(Stream::Stdin) && atty::is(Stream::Stdout);
        Self {
            dry_run,
            no_gh,
            interactive,
            config_path,
            config,
            config_dirty: false,
        }
    }

    fn repo_config(&self, repo: &str) -> Option<&RepoConfig> {
        self.config.repos.get(repo)
    }

    fn repo_config_mut(&mut self, repo: &str) -> &mut RepoConfig {
        self.config
            .repos
            .entry(repo.to_string())
            .or_insert_with(RepoConfig::default)
    }

    fn is_repo_skipped(&self, repo: &str) -> bool {
        self.repo_config(repo).map_or(false, |cfg| cfg.skip)
    }

    fn repo_account(&self, repo: &str) -> Option<&str> {
        self.repo_config(repo)
            .and_then(|cfg| cfg.account.as_deref())
    }

    fn mark_repo_skip(&mut self, repo: &str, skip: bool) {
        let cfg = self.repo_config_mut(repo);
        cfg.skip = skip;
        if skip {
            println!("[config] {repo} marked to skip.");
        } else {
            println!("[config] {repo} cleared from skip list.");
        }
        self.config_dirty = true;
    }

    fn add_known_account(&mut self, account: &str) {
        if self
            .config
            .known_accounts
            .iter()
            .any(|existing| existing == account)
        {
            return;
        }
        self.config.known_accounts.push(account.to_string());
        self.config.known_accounts.sort();
        self.config.known_accounts.dedup();
        self.config_dirty = true;
    }

    fn assign_account(&mut self, repo: &RepoEntry, account: &str) {
        let cfg = self.repo_config_mut(&repo.name);
        cfg.account = Some(account.to_string());
        cfg.skip = false;
        self.add_known_account(account);
        self.config_dirty = true;
        println!("[config] {} assigned account '{}'.", repo.name, account);
    }

    fn ensure_saved(&mut self) -> Result<()> {
        if !self.config_dirty {
            return Ok(());
        }
        if let Some(parent) = self.config_path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("creating config directory {}", parent.display()))?;
        }
        let serialized = toml::to_string_pretty(&self.config).context("serializing config")?;
        let mut file = fs::File::create(&self.config_path)
            .with_context(|| format!("creating {}", self.config_path.display()))?;
        file.write_all(serialized.as_bytes())
            .with_context(|| format!("writing {}", self.config_path.display()))?;
        self.config_dirty = false;
        Ok(())
    }

    fn ensure_repo_account(&mut self, repo: &RepoEntry) -> Result<bool> {
        if self.is_repo_skipped(&repo.name) {
            println!("[skip] {} (configured skip)", repo.name);
            println!();
            return Ok(false);
        }

        if self.repo_account(&repo.name).is_some() {
            return Ok(true);
        }

        if !self.interactive {
            eprintln!(
                "[warn] No account configured for {}. Edit {} or rerun interactively.",
                repo.name,
                self.config_path.display()
            );
            println!();
            return Ok(false);
        }

        println!("[prompt] No GitHub account configured for {}.", repo.name);
        if !self.config.known_accounts.is_empty() {
            println!(
                "Known accounts: {}",
                self.config.known_accounts.join(", ")
            );
        }

        loop {
            let prompt_text = format!(
                "Enter GitHub account for {} ('skip' to ignore)",
                repo.name
            );
            let value: String = Input::new()
                .with_prompt(prompt_text.clone())
                .interact_text()?;
            let trimmed = value.trim();
            if trimmed.eq_ignore_ascii_case("skip") || trimmed.is_empty() {
                self.mark_repo_skip(&repo.name, true);
                println!();
                return Ok(false);
            }

            self.assign_account(repo, trimmed);
            println!();
            return Ok(true);
        }
    }
}

struct RunnerContext {
    dry_run: bool,
    no_gh: bool,
    token_cache: Mutex<HashMap<String, Option<String>>>,
}

impl RunnerContext {
    fn new(dry_run: bool, no_gh: bool) -> Self {
        Self {
            dry_run,
            no_gh,
            token_cache: Mutex::new(HashMap::new()),
        }
    }

    fn token_for(&self, account: &str) -> Result<Option<String>> {
        if self.no_gh {
            return Ok(None);
        }
        {
            let cache = self.token_cache.lock().unwrap();
            if let Some(value) = cache.get(account) {
                return Ok(value.clone());
            }
        }

        let output = Command::new("gh")
            .args(["auth", "token", "-h", "github.com", "--user", account])
            .output();

        let token = match output {
            Ok(out) if out.status.success() => {
                let value = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if value.is_empty() {
                    None
                } else {
                    Some(value)
                }
            }
            Ok(_) => None,
            Err(_) => None,
        };

        let mut cache = self.token_cache.lock().unwrap();
        cache.insert(account.to_string(), token.clone());
        Ok(token)
    }

    fn git_command(&self, task: &RepoTask, args: &[&str]) -> Result<Output> {
        if self.dry_run {
            return Err(anyhow!("dry-run"));
        }

        let mut cmd = Command::new("git");
        cmd.arg("-C").arg(&task.entry.path);
        cmd.arg("-c").arg("credential.helper=");
        cmd.args(args);

        let mut askpass = None;

        if let Some(account) = task.account.as_deref() {
            if let Some(token) = self.token_for(account)? {
                let mut file = NamedTempFile::new().context("creating askpass script")?;
                file.write_all(
                    b"#!/usr/bin/env bash\ncase \"$1\" in\n  *Username*) printf '%s\\n' \"${GH_ASKPASS_USERNAME}\" ;;\n  *Password*) printf '%s\\n' \"${GH_ASKPASS_PASSWORD}\" ;;\n  *) printf '\\n' ;;\nesac\n",
                )
                .context("writing askpass script")?;
                let mut perms = file.as_file().metadata()?.permissions();
                perms.set_mode(0o700);
                file.as_file().set_permissions(perms)?;
                cmd.env("GIT_TERMINAL_PROMPT", "0");
                cmd.env("GIT_ASKPASS", file.path());
                cmd.env("GH_ASKPASS_USERNAME", "x-access-token");
                cmd.env("GH_ASKPASS_PASSWORD", token);
                askpass = Some(file);
            }
        }

        let output = cmd.output().with_context(|| {
            format!(
                "executing git {} in {}",
                args.join(" "),
                task.entry.name
            )
        });

        drop(askpass);
        output
    }
}

fn run_jobs_parallel<F>(ctx: Arc<RunnerContext>, tasks: Vec<RepoTask>, job: F) -> Result<()>
where
    F: Fn(&RunnerContext, &RepoTask) -> Result<JobResultOutput> + Send + Sync + 'static,
{
    let job = Arc::new(job);
    if tasks.is_empty() {
        return Ok(());
    }

    let mut slots: Vec<Option<Result<JobResultOutput>>> = Vec::with_capacity(tasks.len());
    slots.resize_with(tasks.len(), || None);
    let results: Arc<Mutex<Vec<Option<Result<JobResultOutput>>>>> = Arc::new(Mutex::new(slots));

    thread::scope(|scope| {
        for (idx, task) in tasks.into_iter().enumerate() {
            let ctx = ctx.clone();
            let results = results.clone();
            let job = job.clone();
            let repo_name = task.entry.name.clone();
            scope.spawn(move || {
                let res = job(&ctx, &task);
                eprintln!("[done] {}", repo_name);
                results.lock().unwrap()[idx] = Some(res);
            });
        }
    });

    let results = Arc::try_unwrap(results)
        .unwrap()
        .into_inner()
        .unwrap();

    for res in results {
        match res {
            Some(Ok(job)) => {
                print!("{}", job.output);
            }
            Some(Err(err)) => {
                eprintln!("[warn] {}", err);
            }
            None => {
                eprintln!("[warn] missing job result");
            }
        }
    }

    Ok(())
}

fn job_status(ctx: &RunnerContext, task: &RepoTask) -> Result<JobResultOutput> {
    let mut output = String::new();
    output.push_str(&format!("==> {}\n", task.entry.name));

    if ctx.dry_run {
        output.push_str(&format!(
            "DRY: git -C {} status -sb\n\n",
            task.entry.path.display()
        ));
        return Ok(JobResultOutput { output });
    }

    let cmd_output = ctx.git_command(task, &["status", "-sb"])?;
    output.push_str(&String::from_utf8_lossy(&cmd_output.stdout));
    if !cmd_output.stderr.is_empty() {
        output.push_str(&String::from_utf8_lossy(&cmd_output.stderr));
    }
    if !output.ends_with('\n') {
        output.push('\n');
    }

    if !cmd_output.status.success() {
        output.push_str(&format!("[warn] git status failed in {}\n\n", task.entry.name));
    } else {
        output.push('\n');
    }

    Ok(JobResultOutput { output })
}

fn job_pull(ctx: &RunnerContext, task: &RepoTask) -> Result<JobResultOutput> {
    let mut output = String::new();
    output.push_str(&format!("==> {}\n", task.entry.name));

    if ctx.dry_run {
        output.push_str(&format!(
            "DRY: git -C {} status -sb\nDRY: git -C {} pull --ff-only\n\n",
            task.entry.path.display(),
            task.entry.path.display()
        ));
        return Ok(JobResultOutput { output });
    }

    let status_out = ctx.git_command(task, &["status", "-sb"])?;
    output.push_str(&String::from_utf8_lossy(&status_out.stdout));
    if !status_out.stderr.is_empty() {
        output.push_str(&String::from_utf8_lossy(&status_out.stderr));
    }
    if !output.ends_with('\n') {
        output.push('\n');
    }

    let pull_out = ctx.git_command(task, &["pull", "--ff-only"])?;
    output.push_str(&String::from_utf8_lossy(&pull_out.stdout));
    if !pull_out.stderr.is_empty() {
        output.push_str(&String::from_utf8_lossy(&pull_out.stderr));
    }

    if !(status_out.status.success() && pull_out.status.success()) {
        output.push_str(&format!("[warn] git pull failed in {}\n", task.entry.name));
    }

    output.push('\n');
    Ok(JobResultOutput { output })
}

fn job_fetch_status(ctx: &RunnerContext, task: &RepoTask, prune: bool) -> Result<JobResultOutput> {
    let mut output = String::new();
    output.push_str(&format!("==> {}\n", task.entry.name));

    if ctx.dry_run {
        output.push_str(&format!(
            "DRY: git -C {} fetch{}\nDRY: git -C {} status -sb\n\n",
            task.entry.path.display(),
            if prune { " --prune" } else { "" },
            task.entry.path.display()
        ));
        return Ok(JobResultOutput { output });
    }

    let fetch_args = if prune { vec!["fetch", "--prune"] } else { vec!["fetch"] };
    let fetch_out = ctx.git_command(task, &fetch_args)?;
    output.push_str(&String::from_utf8_lossy(&fetch_out.stdout));
    if !fetch_out.stderr.is_empty() {
        output.push_str(&String::from_utf8_lossy(&fetch_out.stderr));
    }

    if !fetch_out.status.success() {
        output.push_str(&format!(
            "[warn] git fetch failed in {}\n",
            task.entry.name
        ));
    }

    let status_out = ctx.git_command(task, &["status", "-sb"])?;
    output.push_str(&String::from_utf8_lossy(&status_out.stdout));
    if !status_out.stderr.is_empty() {
        output.push_str(&String::from_utf8_lossy(&status_out.stderr));
    }

    if !output.ends_with('\n') {
        output.push('\n');
    }
    output.push('\n');

    Ok(JobResultOutput { output })
}

fn resolve_root(root_arg: Option<&Path>) -> Result<PathBuf> {
    let base = if let Some(path) = root_arg {
        if path.is_absolute() {
            path.to_path_buf()
        } else {
            env::current_dir()
                .context("resolving current directory")?
                .join(path)
        }
    } else {
        env::current_dir().context("resolving current directory")?
    };

    let resolved = fs::canonicalize(&base)
        .with_context(|| format!("resolving root directory {}", base.display()))?;

    if !resolved.is_dir() {
        bail!("root path {} is not a directory", resolved.display());
    }

    Ok(resolved)
}

fn list_child_repos(base: &Path) -> Result<Vec<RepoEntry>> {
    let mut repos = Vec::new();
    for entry in fs::read_dir(base).with_context(|| format!("reading {}", base.display()))? {
        let entry = entry?;
        if !entry.file_type()?.is_dir() {
            continue;
        }
        let repo_path = entry.path();
        if repo_path.join(".git").is_dir() {
            let name = repo_path
                .file_name()
                .map(|s| s.to_string_lossy().to_string())
                .unwrap_or_else(|| repo_path.display().to_string());
            repos.push(RepoEntry { name, path: repo_path });
        }
    }
    repos.sort_by(|a, b| a.name.cmp(&b.name));
    Ok(repos)
}

fn default_config_path(cli_override: Option<PathBuf>) -> Result<PathBuf> {
    if let Some(path) = cli_override {
        return Ok(path);
    }

    let home = dirs::home_dir().context("locating home directory")?;
    let dir = home.join(CONFIG_DIR_NAME);
    Ok(dir.join(CONFIG_FILE_NAME))
}

fn load_config(path: &Path) -> Result<Config> {
    if path.exists() {
        let data = fs::read_to_string(path)
            .with_context(|| format!("reading {}", path.display()))?;
        let config = toml::from_str(&data).with_context(|| format!("parsing {}", path.display()))?;
        Ok(config)
    } else {
        Ok(Config::default())
    }
}

fn gather_tasks(ctx: &mut AppContext, repos: Vec<RepoEntry>) -> Result<Vec<RepoTask>> {
    let mut tasks = Vec::new();

    for repo in repos {
        if !ctx.ensure_repo_account(&repo)? {
            continue;
        }
        let account = ctx
            .repo_account(&repo.name)
            .map(|s| s.to_string());
        tasks.push(RepoTask { entry: repo, account });
    }

    Ok(tasks)
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    let config_path = default_config_path(cli.config.clone())?;
    let config = load_config(&config_path)?;
    let mut ctx = AppContext::new(cli.dry_run, cli.no_gh, config_path, config);

    let repo_root = resolve_root(cli.root.as_deref())?;
    let mut repos = list_child_repos(&repo_root)?;

    let tasks = match cli.command {
        CommandKind::Status => gather_tasks(&mut ctx, repos)?,
        CommandKind::Pull => gather_tasks(&mut ctx, repos)?,
        CommandKind::FetchStatus { include_current, .. } => {
            if include_current && repo_root.join(".git").is_dir() {
                let current = RepoEntry {
                    name: repo_root
                        .file_name()
                        .map(|s| s.to_string_lossy().to_string())
                        .unwrap_or_else(|| repo_root.display().to_string()),
                    path: repo_root.clone(),
                };
                repos.insert(0, current);
            }
            gather_tasks(&mut ctx, repos)?
        }
    };

    let runner = Arc::new(RunnerContext::new(ctx.dry_run, ctx.no_gh));

    match cli.command {
        CommandKind::Status => {
            run_jobs_parallel(runner, tasks, |runner_ctx, task| job_status(runner_ctx, task))?;
        }
        CommandKind::Pull => {
            run_jobs_parallel(runner, tasks, |runner_ctx, task| job_pull(runner_ctx, task))?;
        }
        CommandKind::FetchStatus { no_prune, .. } => {
            let prune = !no_prune;
            run_jobs_parallel(runner, tasks, move |runner_ctx, task| {
                job_fetch_status(runner_ctx, task, prune)
            })?;
        }
    }

    println!("All done.");

    ctx.ensure_saved()?;
    Ok(())
}
