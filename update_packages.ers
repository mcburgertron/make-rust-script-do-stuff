#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4", features = ["derive"] }
//! anyhow = "1"
//! ```

use std::process::Command;
use anyhow::{Context, Result, bail};
use clap::Parser;
use std::env;
use std::path::PathBuf;

#[derive(Parser)]
#[command(author, version, about = "Update system packages using the platform's package manager")]
struct Cli {
    /// Print commands without executing them
    #[arg(long)]
    dry_run: bool,
}

fn run_command(cmd: &str, args: &[&str], dry_run: bool) -> Result<()> {
    if dry_run {
        println!("{} {}", cmd, args.join(" "));
        return Ok(());
    }
    let status = Command::new(cmd)
        .args(args)
        .status()
        .with_context(|| format!("failed to execute {}", cmd))?;
    if !status.success() {
        bail!("{} exited with status {}", cmd, status);
    }
    Ok(())
}

fn is_termux_env() -> bool {
    env::var("PREFIX").map_or(false, |p| p.contains("com.termux"))
        || std::fs::metadata("/data/data/com.termux/files").is_ok()
}

fn has_cmd(cmd: &str) -> bool {
    if cmd.contains('/') { return std::path::Path::new(cmd).exists(); }
    if let Ok(path) = env::var("PATH") {
        for p in path.split(':') {
            let mut pb = PathBuf::from(p);
            pb.push(cmd);
            if cfg!(windows) {
                if pb.with_extension("exe").exists() { return true; }
            }
            if pb.exists() { return true; }
        }
    }
    false
}

fn update(dry_run: bool) -> Result<()> {
    let os = std::env::consts::OS;
    match os {
        "linux" | "android" => {
            // Prefer system package managers when available, then fallback to Termux.
            if has_cmd("apt-get") {
                return run_command(
                    "sudo",
                    &[
                        "sh",
                        "-c",
                        "apt-get update && apt-get upgrade -y && apt-get autoremove -y",
                    ],
                    dry_run,
                );
            }
            if has_cmd("dnf") {
                run_command("sudo", &["dnf", "upgrade", "-y"], dry_run)?;
                return run_command("sudo", &["dnf", "autoremove", "-y"], dry_run);
            }
            if has_cmd("yum") {
                run_command("sudo", &["yum", "update", "-y"], dry_run)?;
                return run_command("sudo", &["yum", "autoremove", "-y"], dry_run);
            }
            if has_cmd("pacman") {
                return run_command("sudo", &["pacman", "-Syu", "--noconfirm"], dry_run);
            }
            if has_cmd("zypper") {
                run_command("sudo", &["zypper", "refresh"], dry_run)?;
                return run_command("sudo", &["zypper", "update", "-y"], dry_run);
            }
            // Termux (only when system managers are not present)
            if is_termux_env() {
                run_command("pkg", &["update"], dry_run)?;
                return run_command("pkg", &["upgrade", "-y"], dry_run);
            }
            bail!("could not detect supported Linux package manager (apt, dnf, yum, pacman, zypper)");
        }
        "macos" => {
            run_command("brew", &["update"], dry_run)?;
            run_command("brew", &["upgrade"], dry_run)
        }
        "windows" => {
            run_command(
                "winget",
                &[
                    "upgrade",
                    "--all",
                    "--include-unknown",
                    "--accept-source-agreements",
                    "--accept-package-agreements",
                ],
                dry_run,
            )
        }
        other => bail!("unsupported operating system: {}", other),
    }
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    update(cli.dry_run)
}
